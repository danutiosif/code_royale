#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;


int closest(std::vector<int> const& vec, int value);
  

int main()
{
    int numSites;
    cin >> numSites; cin.ignore();
    
    vector<int> sitesID;
    vector<int> sitesXCoordinate;
    vector<int> sitesYCoordinate;
    
    bool builtFirstSite = false;

    bool availableTraining = false;
    int availableTrainingSite = -1;
    int availableUnitTrain = -1;
    bool jobDone = false;

    //Initial loop. The only way to get the coordinates for the sites
    for (int i = 0; i < numSites; i++) 
    {
        int siteId;
        int x;
        int y;
        int radius;
        cin >> siteId >> x >> y >> radius; cin.ignore();

        sitesID.push_back(siteId);
        sitesXCoordinate.push_back(x);
        sitesYCoordinate.push_back(y);
    }

    int closestSite;

    // game loop
    while (1) 
    {
        int gold;
        int touchedSite; // -1 if none, siteId of the touched site
        cin >> gold >> touchedSite; cin.ignore();
        //loop for each site
        for (int i = 0; i < numSites; i++) 
        {
            int siteId; //The numeric identifier of the site
            int ignore1; // used in future leagues
            int ignore2; // used in future leagues
            int structureType; // -1 = No structure, 2 = Barracks
            int owner; // -1 = No structure, 0 = Friendly, 1 = Enemy
            int param1; // -1 = No Barracks, 0 = Unit training available, X (1, 2, 3) = number of turns until the unit training is available
            int param2; // -1 = No structure, 0 = KNIGHT, 1 = ARCHER
            cin >> siteId >> ignore1 >> ignore2 >> structureType >> owner >> param1 >> param2; cin.ignore();

            if (param1 == 0 && owner == 0)
            {
                availableTraining = true;
                availableTrainingSite = siteId;
                //availableUnitTrain = param2; TODO: Not yet used
            }
        }
        int numUnits;
        cin >> numUnits; cin.ignore();
        for (int i = 0; i < numUnits; i++) 
        {
            int x; //Coordinates of the units
            int y; //Coordinates of the units
            int owner; // 0 = Friendly, 1 = Enemy
            int unitType; // -1 = QUEEN, 0 = KNIGHT, 1 = ARCHER
            int health;
            cin >> x >> y >> owner >> unitType >> health; cin.ignore();
        }


            /***********************************************************/
        /************************* MOVE/BUILD COMMANDS *********************/
            /***********************************************************/

        if (!builtFirstSite)
        {
            closestSite = closest(sitesXCoordinate, 1000);                                
            cout << "BUILD " << sitesID[closestSite] << " BARRACKS-KNIGHT" << endl;
        }


        if (builtFirstSite)
        {
            if (touchedSite == sitesID[closestSite])
            {
                sitesXCoordinate.erase(sitesXCoordinate.begin() + closestSite);
                closestSite = closest(sitesXCoordinate, sitesXCoordinate[closestSite]);    
            }
            
            cout << "BUILD " << sitesID[closestSite] << " BARRACKS-KNIGHT" << endl;
        }



            /***********************************************************/
        /************************* TRAIN COMMANDS **************************/
            /***********************************************************/
        

        if (availableTraining)
        {
            builtFirstSite = true;
            cout << "TRAIN " << availableTrainingSite << endl;
            jobDone = true;
        }
        else
        {
            jobDone = false;
            cout << "TRAIN" << endl;    
        }
    }
}
 
int closest(std::vector<int> const& vec, int value) {
    auto const it = std::lower_bound(vec.begin(), vec.end(), value);
    int threshold = 100, found = 0;

    for (int i = 0; i < vec.size();i++)
    {
        if ( abs(vec[i] - value) < threshold)
        {
            found = i;
            threshold = abs(vec[i] - value);
        }
    }

    return found;
}


